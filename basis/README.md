# 计算机基础实验的一些说明

找的到的东西都翻上来了（2021），不过听说内容改了，但应该改不到哪里去，毕竟是抄的国外的实验材料。

时间有点久，有几个实验记不清了，反正先这样吧。

## lab1 datalab

> **有限操作符的位运算实现**

提供了三个版本的实现：

- bits.c 正常做的版本，包括刷榜过程中重写的各个版本
- bits_high-score.c 极限刷榜版
- bits_normal-score.c 回拉了下 op 数，属于比较正常的版本

datalab 的位运算实现应该不止这些，所以当年的实验题库可能跟 2021 年的不完全一样。没有的部分就需要自己写了。

## lab2 buflab

> **忘了×1，应该是缓冲区攻击修改跳转地址？**

乐，这个我好像没写脚本，因为基本都做出来了。

## lab3 bomblab

> **忘了×2，不过应该差不多是是走流程抓返回值**

gdb 打断点慢慢跑吧，应该挺快。

这实验好像是要抓 6 个密码，简单讲讲吧。

### 关于 gdb 调试的说明

如果使用的是虚拟机，那可以跳过该部分。

如果使用的是 WSL2，可以安装 qemu-user 进行实验。该实验的程序使用 `-ggdb` 选项编译，所以不用担心没有调试信息。参考启动步骤如下：

qemu 启动 gdb 服务并运行程序：

```sh
qemu-i386 -g 1234 ./bomb-quiet -f ans
```

> 由于 bomb 程序执行时若不存在输入程序会尝试从输入流读取，这会导致调试过程被 IO 打断，对于使用不熟练的同学可能会造成一些麻烦，故此处建议直接指定输入文件。

此处提供了 Makefile 和 i386 下 gdb 的配置，直接使用 make 启动 gdb 即可：

```sh
make gdb TARGET=./bomblab/bomb-quiet
```

> TARGET 为执行需要调试的程序，此处主要是为了为远程调试加载符号信息。
>
> 由于 gdb 启动引用了相对路径下的配置文件，故请务必确保 make gdb 在当前目录下运行（./basis），详情见 Makefile。

### phase 1

**方法一：赌狗法**

命令 `strings bomb-quiet` 打印出字符串，找一个你觉得最格格不入的并且看上去像是个英语句子的字符串，那基本就是密码了。

**方法二：常规**

gdb 启动，断点打在 phase_1，第一个 strings_not_equal 调用第一个压栈的参数就是密码的地址了。

参考 gdb 命令：

```gdb
b *(phase_1+14)
c
x /s *(void**)($esp+4)
```

### phase 2

1. 不难得该步读入 6 个整数
2. 有前向 jmp，是一个循环
3. 循环内 explode_bomb 的入口是一个 cmp 指令，追溯后的指令为 `cmp [$ebp]+[$ebp+4], [$ebp+8]`

好了这是个斐波那契数列，初值由跳转至第一个 explode_bomb 的 cmp 给出。

参考 gdb 命令：

```gdb
define hook-stop
x /6d $ebp-24
p *(int(*)[6])($ebp-0x24)
printf "cmp $eax, [$ebx+8] ~ %lx <> %lx\n", $eax, *($ebx+8)
end
b *(phase_2+34)
b *(phase_2+62)
```

> hook-stop 会在每次 gdb 每次暂停时运行，合理使用有助于调试。
>
> 不同人的内容可能不一样，但基本都是简单循环。

### phase 3

套路基本一样，关注跳转至 explode_bomb 的条件跳转。

然后发现，呵，跳转还挺多。注意到有个存储器比例变址寻址 `jmp *0x8049380(,%eax,4)`，你得晓得这八九不离十是一个 switch 查表跳转。（请自行记录自己的跳转表地址）

先看前面的 sscanf，这指明了你的输入格式。sscanf 的声明类似于 `int sscanf(buffer, fmtstr, ...)`，所以查看第二个参数的内容，得到格式化字符串，此处假设是 "%d %c %d"。

第一个 explode_bomb 是对 sscanf 调用的检查，可以跳过。

接下来就来到了令人激动的 switch 跳转！

首先我们勾引一波，打出跳转表的 8 个跳转地址 `x /8w 0x8049380`，得到以下内容：

```plain
0x8049380: 0x080489ed 0x08048a0e 0x08048a2f 0x08048a4d
0x8049390: 0x08048a67 0x08048a7e 0x08048a98 0x08048ab2
```

此处跳转的 \$eax 来自 \[$ebp-0x14]，也就是第一个输入的整数。

好了，现在可以使用**瞪眼法**了，请自行看看这几个跳转地址上哪一个分支是能够继续运行下去不会 BOMB 的。

例如第 0 个地址 `0x080489ed` 上是**安全**的，那么相应的第一个整数就应该是 0。

`0x080489ed` 紧跟着 `cmpl $0x3c5, -0x10(%ebp)`，此处 \[$ebp-0x10] 对应第二个整数，故得到其值应当为 0x3c5 也即 965。

> 关于输入与变量的对应关系观察 sscanf 的参数压栈，i386 自右向左压栈，故 push 的第 1、2、3 个地址分别对应第二个整数，字符，第一个整数的变量地址。

关注下此处对 $eax 的赋值 0x73，对应字符 's'，继续执行发现来到最后一个比较 `cmp -0x15(%ebp), %al`，这正是对输入的字符的比较，故得到字符的值应为 s。

> al 寄存器对应 eax 的低 8 位。

参考 gdb 命令：

```gdb
b *(phase_3+37)
c
x /s *(void**)($esp+4)
b *(phase_3+68)
c
x /8wx 0x8049380
si 3
si 2
```

### phase 4

同 phase 3，首先看一波输入格式并记下输入与变量地址的对应关系。

此处假设是 "%d %d" 并且两个整数分别对应 \[$ebp-0x10] 和 \[$ebp-0x14]。

phase 4 的逻辑很短，但是有内部调用 func4。

观察 call 与 cmp 指令可以知道 phase 4 的判定条件是 `func4(第一个参数, 第二个整数) == 第一个整数`

其中对第二个整数（记为 n）的要求如下：

```asm
mov -0x14(%ebp),%eax
sub $0x2,%eax
cmp $0x2,%eax
jbe 0x8048b7c <phase_4+62>
```

也即应当满足 `(unsigned)(n - 2) <= 2`，可得 n 的取值集合为 {2, 3, 4}。

> 注意 jmp 指令的后缀， **a**bove/**b**elow 是无符号比较，**g**reater/**l**ess 是有符号比较

注意到 func4 是一个纯函数，也就是说 func4 的求值并不需要分析，当个黑盒传入参数拿到结果就行了。故在 call func4 的下一条指令打上断点，得到返回值也就是 \$eax。

在满足 n 的条件之后，调用 func4 后返回值 $eax 就是第一个整数的数值。

> 由于此处除了 n 的范围约束后并没有更多的限制，所以 phase 4 其实存在多个结果

参考 gdb 命令：

```gdb
b *(phase_4+33)
c
b *(phase_4+75)
c
p $eax
```

### phase 5

> 坏消息：phase 5 又是一个循环
>
> 好消息：循环体非常短

观察输入格式，芜湖，调用了 string_length 并判了返回值，看一眼 cmp 发现长度必须为 6（具体值以实际为准）。

观察主要逻辑（字符串长度检查之后），发现用的寄存器还挺多，梳理下上下文得到寄存器赋值：

```plain
$ebx: 字符串地址+0x6
$eax: 字符串地址
$ecx: 0x0
$edx: $eax[0]
```

注意到这个 6 非常的微妙，$ebx 与字符串的偏移刚好为 6，循环体中 $eax 每次自增 1，而 $eax 又与 ebx 比较决定跳转地址。

不难发现这是个遍历字符串字符的过程。

然后又是一个复杂的存储器寻址 `add 0x80493a0(,%edx,4),%ecx`，但好在逻辑异常简单，易知是查表自增。

不难翻译为以下代码：

```c
void f(char *s) {
    eax = s;
    ebx = s + 6;
    ecx = 0;
    while (eax < ebx) {
        edx = *eax;
        ecx += table[edx & 0xf];
        ++eax;
    }
    CHECK(ecx == 0x2c);
}
```

由每次循环 $edx 的取值可知表的大小至少为 16，根据寻址变比可以知道每个元素的大小为 4 字节。

故 `x /16wd 0x80493a0` 查表：

```plain
 2  10    6    1
12  16    9    3
 4   7   14    5
11   8   15   13
```

好了，到目前为止，这个问题已经变成了一个益智类凑数问题：

```plain
请选出上面 16 个数字中的 6 个数字，使他们的和为 0x2c（数字可重复使用）。
```

答案的个数不可想象，想知道具体是多少的请自行深搜并排列组合并考虑可打印字符的个数并将它们倍乘（这个计算其实还挺麻烦的，因为索引只需要取低八位就行了，故你还需要考虑 scanf 读入的字符集合）。

凑出一个答案其实非常简单，注意到 '0' 的低 8 位恰好就是 0x0，所以凑出你的索引序列后只需要将它们顺序映射到 `{'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=', '>', '?'}`。

举个例子：

```plain
0x2c == 44 = 15 * 2 + 11 + 1 * 3
          <= [14] * 2 + [12] + [3] * 3
          <= '>' * 2 + '<' + '3' * 3
          <= ">><333"
```

参考 gdb 命令：

```gdb
b phase_5
c
b *(phase_5+39)
printf "eax: %#lx, \"%s\"\nebx: %d\necx: %d\nedx: '%c' %d %#x\n", $eax, $eax, $ebx, $ecx, $edx, $edx, $edx
x /16wd 0x80493a0
```

### phase 6

瞅一眼，又是读 6 个数。

再瞅一眼，吼，不仅长而且还不止一个循环。

先根据 read_six_number 压栈情况找到数的读入基地址 \$ebp-0x3c，读入结束完后验证下 `p *(int(*)[6])($ebp-0x3c)`。

然后第一个循环就来了，瞅一眼循环体的第一个指令 `mov -0x3c(%ebp,%esi,4),%eax`，注意到 \$esi 是自增的，好了，一眼就知道第一个循环遍历了 6 个数干了不知道什么偷鸡摸狗的事。

小小偷窥一下发现了判定条件是 `(unsigned)($eax - 1) <= 5`，好了，这下知道*数字的范围是 1~6 了*。

~~**你眉头一皱，发现事情并不简单，范围都有了，那穷举 6^6 次不就出结果了？**~~

直接转到第二个循环（注意要根据循环结束的跳转地址判断，不能默认是从上而下的第二个循环部分）。

> 循环体的起始位置可以通过前向 jmp 的目的地址判断。

然后你会发现，事情好似越发不妙起来，这个时候不妨停下来，把代码全部过一遍。

然后你就会发现这样的语句 `mov 0x8(%edx), %edx`，这合理吗？这太合理了，这不就是链表遍历的常用方式吗！不难得出 %edx 所代表的实例有这样的类型，而其本身就是链表节点的一个指针：

```cpp
struct node {
    u32   _1;
    u32   _2;
    node *next;
};
```

> 注意到该点需要了解结构体的访问成员的偏移寻址方式

这下不少事情都明朗起来了。

$edx 的第一次赋值在第一个循环结束之后，其值为 0x804b134，通过迭代偏移访问 next 成员可以得到以 0x804b134 为链表根节点的所有链表节点。

> 打印一下就会发现其实这地址的数据是有符号信息的（node1），所以用 gdb 输入 `p node` 然后补全一下就可以知道一共有 node1/node2/node3/node4/node5/node6 总共 6 个节点，或者也可以在外边直接 nm 一下。
>
> 进一步观察下符号信息可知这 6 个节点在 bss 段连续存储，所以要看数据的话不用真一个一个遍历，直接一次性输出就行。

勾引一下看看 6 个节点的数据 `p *(int(*)[6][3])&node1`，进一步明确节点结构如下：

```cpp
struct node {
    u32   value;
    u32   index;
    node *next;
};
```

**回到正轨**

在第一个循环结束之后，进入一个 8 条指令的逻辑块。

```plain
mov $0x0,%ebx
mov %ebx,%esi
mov -0x3c(%ebp,%ebx,4),%ecx
mov $0x1,$eax
mov $0x804b134,%edx
cmp $0x1,%ecx
jg  0x8048c4e <phase_6+91>
jmp 0x8048c58 <phase_6+101>
```

此时第一个数的值被 \$ecx 持有，当 \$ecx 大于 1 时，跳转到 <phase_6+91> 处，等于 1 时跳转到 <phase_6+101> 处。

先看 <phase_6+91> 处的代码，在有了前面关于链表节点的基础后，可以知道该部分的第一个循环体用于将 $edx 定位到第 $ecx 个节点。

查找完之后，紧接着就进入 <phase_6+101> 部分的代码。

不难发现两个部分其实是一体的，只不过当 $ecx 为 1 时，$edx 本身就是第 $ecx 个节点，不再需要通过 <phase_6+91> 处的逻辑更新。

<phase_6+101> 部分，分析 `mov %edx,-0x24(%ebp,%esi,4)`：\$ebp-0x24 处已经脱离了 6 个输入整数的区间，故可以判断为该部分是一个存储节点地址的数组（记为 tmp_nodes）。

该操作将当前 \$edx 节点写入 tmp_nodes[\$esi]。

其后的两个跳转 <phase_6+120>，<phase_6+143> 中，后者已经达到方法的末尾，而 <phase_6+120> 跳转至一个函数体。在这个过程中涉及 \$ebx 和 \$esi 的访问、更新与比较。

故 \$ebx 和 \$esi 基本可以确定为是 <phase_6+120> 处循环的循环变量。

而 <phase_6+120> 将 <phase_6+101> 处的 \$ebx 自增传递给了 \$esi 并访问了第 \$ebx 个输入整数，连贯起来便可得到这一大段循环实现了**以输入数字为索引将全局链表节点顺序拷贝至栈上数组**。

分析完成，直接进入下一部分 <phase_6+143>。

天啊，这一部分简直是简单明了：遍历栈上数组 tmp_nodes。

分析最终的循环体 <phase_6+154>，翻译如下：

```cpp
node  *ebx = tmp_nodes[0];
node **eax = tmp_nodes + 0;
node **esi = tmp_nodes + 5;
ecx = ebx;
do {
    edx = eax + 1;
    ecx->next = edx;
    ++eax;
    ecx = edx;
} while (eax != esi);
```

显然易见，是重建链表节点的链接（包括最后一个节点的 next 置空）。

最后的判定代码：

```cpp
esi = 5;
do {
    eax = ebx->next;
    if (!(eax->value >= ebx->value)) {
        explode_bomb();
    }
    --esi;
} while (esi != 0);
```

> 汇编哪有什么复合类型，我 eax 一下是 node** 一下是 node* 很正常吧？

> 条件转移指令通过符号寄存器决定是否跳转，而除了 cmp 指令之外，sub 指令也会影响符号寄存器的值。如果你发现了 jne 但是没有发现 cmp 或者上一条 cmp 距离很远，那么请不要疑惑，因为该条件跳转可能由更近的 sub 指令决定。

注意到 eax 总是 ebx 的后继，故 phase 6 最终归结为**重排序 node1-6 节点，令它们的 value 降序排列**。

~~**于是你又发现只要穷举排列 6! 次就必定能试出答案，这简直太可行了！**~~

```gdb
b phase_6
b *(phase_6+34)
c
c
p *(int(*)[6])($ebp-0x3c)
b *(phase_6+115)
c
b *(phase_6+139)
c
b *(phase_6+91)
b *(phase_6+101)
b *(phase_6+120)
b *(phase_6+143)
b *(phase_6+181)
p *(int(*)[6][3])&node1
```

## lab4 linklab

> **忘了×3，这个彻底忘了要干啥了**

提供了 solve 的源码和配套脚本，**运气好的话**几秒就能做完。

跑 `./script/one-shot.sh` 可以环境建立、初始化、解题、提交、打包一步到位，具体怎么跑请看脚本。

但还是那句话，注意是**运气好的话**。

one-shot.sh 包含直接提交的步骤，但是错误提交我记得是会影响分数的，所以建议先完成到解题这步，然后自己检查下。解题应该是 build.sh 吧，具体实现可以看 src 下的源码（解题直接用 solve-phase 更方便些）。

phase1-4 应该不会有什么问题，就正常步骤，只要实验内容别改的太离谱的话应该都能过。

phase5 用了取巧的方法，因为当时做完发现这玩意的关键部分是有标程的。当时搜集了八个班的实验材料最后发现只有两套模式，所以分别把这两套做了下把标程打成了 ./assets/phase5.std.1 和 ./assets/phase5.std.2，而此处 phase5 的解题方法其实就是匹配下模式选择使用哪个标程然后套上，非常简单粗暴。

这次的模式可能不一样，要是直接使用不行的话可以找课上做出来的几份 bin 然后自己打成标程。

> 别问为什么这么干，问就是不需要动脑子。
